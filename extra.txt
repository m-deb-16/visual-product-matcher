# import os
# import streamlit as st
# import faiss
# import torch
# import numpy as np
# import joblib
# from PIL import Image
# from torchvision import models, transforms
# from io import BytesIO
# import requests

# # -----------------------------
# # CONFIG
# # -----------------------------
# st.set_page_config(page_title="Visual Product Matcher", layout="wide")
# DATA_DIR = "data"
# INDEX_PATH = os.path.join(DATA_DIR, "image_index.faiss")
# METADATA_PATH = os.path.join(DATA_DIR, "metadata.pkl")

# # -----------------------------
# # IMAGE TRANSFORM + MODEL
# # -----------------------------
# transform = transforms.Compose([
#     transforms.Resize((224, 224)),
#     transforms.ToTensor(),
#     transforms.Normalize(
#         mean=[0.485, 0.456, 0.406],
#         std=[0.229, 0.224, 0.225]
#     ),
# ])

# @st.cache_resource
# def load_model():
#     model = models.resnet50(pretrained=True)
#     model = torch.nn.Sequential(*list(model.children())[:-1])
#     model.eval()
#     return model

# @torch.no_grad()
# def extract_features(image, model):
#     img_t = transform(image).unsqueeze(0)
#     feat = model(img_t).squeeze().numpy()
#     feat = feat / np.linalg.norm(feat)
#     return feat.astype('float32')

# @st.cache_resource
# def load_index():
#     index = faiss.read_index(INDEX_PATH)
#     metadata = joblib.load(METADATA_PATH)
#     return index, metadata

# # -----------------------------
# # SEARCH FUNCTION
# # -----------------------------
# def search_similar(image, top_k=6):
#     model = load_model()
#     index, metadata = load_index()

#     feat = extract_features(image, model).reshape(1, -1)
#     distances, indices = index.search(feat, top_k)

#     results = []
#     for idx, dist in zip(indices[0], distances[0]):
#         if 0 <= idx < len(metadata):
#             item = metadata[idx]
#             results.append({
#                 "id": item["id"],
#                 "name": item["name"],
#                 "category": item["category"],
#                 "image_path": item["image_path"],
#                 "similarity": float(1 / (1 + dist))
#             })
#     return results

# # -----------------------------
# # UI LAYOUT
# # -----------------------------
# st.title("🖼️ Visual Product Matcher")
# st.markdown("Upload an image or paste an image URL to find visually similar products.")

# col1, col2 = st.columns([1, 2])

# with col1:
#     uploaded_file = st.file_uploader("Upload Image", type=["png", "jpg", "jpeg"])
#     url_input = st.text_input("or Paste Image URL")

#     query_image = None
#     if uploaded_file:
#         query_image = Image.open(uploaded_file).convert("RGB")
#     elif url_input:
#         try:
#             resp = requests.get(url_input)
#             query_image = Image.open(BytesIO(resp.content)).convert("RGB")
#         except:
#             st.error("⚠️ Failed to load image from URL")

#     search_btn = st.button("🔍 Search Similar Products")

# with col2:
#     if query_image is not None:
#         st.image(query_image, caption="Query Image", width=300)

# # -----------------------------
# # SEARCH RESULTS
# # -----------------------------
# if search_btn and query_image is not None:
#     with st.spinner("Extracting features and searching..."):
#         results = search_similar(query_image, top_k=6)

#     st.subheader("🔍 Similar Products")
#     cols = st.columns(3)
#     for i, r in enumerate(results):
#         with cols[i % 3]:
#             st.image(r["image_path"], use_container_width=True)
#             st.markdown(f"**{r['name']}**  \n*{r['category']}*")
#             st.caption(f"Similarity: {r['similarity']:.2f}")

